## How do we deploy
An deploy starts with triggering the AuroraAPI from either of the userfacing clients [AO](aurora#ao), [AuroraKonsole](aurora#auroraKonsole) or [AuroraPipeline](aurora#auroraPipeline). The API will then read and [merge AuroraConfig](aurora#AuroraConfig) in order to create a AuroraDeploymentSpec. [Synchrous integrations](aurora#integrationSyncronous) are run and the result of both are assembled into Kubernetes objects that are applied to the cluster. Async integrations that use the [controller pattern](https://kubernetes.io/docs/concepts/api-extension/custom-resources/#custom-controllers) are then run. The application is then rolled out either via importing a new image or triggering a new deploy. The [deploy result](aurora#deployResult) is save for later inspection.


History. Move this to main document
We started out using [OpenShift Templates](https://docs.openshift.org/latest/dev_guide/templates.html) in 2015. A go-template based template engine that takes a list of parameters and replaces it into objects before applying them to the cluster. For our needs this technology was and is severly lacking. - no support for conditional logic - no support for loops - no support for optionaly including and entire object We then created a bash wrapper around the templates that would generate objects for it and modify them afterwards. The config for this bash wrapper resided along side the application code. After som experience with this we found several issues with it - writing good bash is hard and testing tools are lacking - no client-server model, so we had to duplicate functionality in web dashboard - you had to commit and change code in repo to change config. That means triggereing new jenkins builds when not really needed. This lead to the design of the start of the AuroraAPI with the [boober](aurorapi/boober), [AuroraConfig](auroraConfig) and [ao](tools/ao) components.
